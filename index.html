<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D魔術方塊</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: system-ui, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; touch-action: none; outline: none; }
        .ui-panel { pointer-events: none; position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: space-between; padding: 2rem; }
        .ui-panel * { pointer-events: auto; }
        .glass-card { background: rgba(15, 23, 42, 0.7); backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 1.5rem; }
        .btn { transition: all 0.2s; background: rgba(56, 189, 248, 0.15); border: 1px solid rgba(56, 189, 248, 0.3); color: #7dd3fc; padding: 0.75rem 1.5rem; border-radius: 1rem; font-weight: 700; }
        .btn:hover { background: rgba(56, 189, 248, 0.25); transform: translateY(-2px); border-color: #38bdf8; box-shadow: 0 0 20px rgba(56, 189, 248, 0.4); }
        * { user-select: none; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-panel">
        <div class="flex justify-between items-start">
            <div class="space-y-1">
                <h1 class="text-3xl font-black tracking-tighter text-white uppercase italic">Cube <span class="text-sky-500">Sense</span></h1>
                <div class="bg-sky-500/10 border border-sky-500/20 px-3 py-1 rounded-full text-[10px] text-sky-400 font-bold uppercase tracking-widest inline-block">
                    穩定校準版 v3.4
                </div>
            </div>
            <div class="text-right">
                <div id="timer" class="text-4xl font-mono font-bold text-white tracking-tight text-shadow-lg">00:00.00</div>
                <div id="status" class="text-xs text-sky-300 mt-1 font-bold">層級自動對齊已啟用</div>
            </div>
        </div>

        <div class="flex justify-center mb-4">
            <div class="glass-card p-4 flex gap-4 shadow-2xl">
                <button id="scramble-btn" class="btn">隨機打亂</button>
                <button id="reset-btn" class="bg-slate-800/80 border border-white/5 text-slate-400 px-6 py-3 rounded-xl font-bold hover:bg-slate-700 hover:text-white transition-colors">重置</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * 3D 魔術方塊 - 穩定校準版
         * 修復了長期旋轉後座標漂移導致的色層錯位問題
         */
        let scene, camera, renderer, raycaster, mouse = new THREE.Vector2();
        let cubes = [];
        let isRotating = false;
        let isDragging = false;
        let dragStartPoint = new THREE.Vector2();
        let selectedData = null;
        
        let lon = 45, lat = 30;
        let phi = 0, theta = 0;
        const target = new THREE.Vector3(0, 0, 0);

        const COLORS = {
            top: 0xffffff, bottom: 0xffd700, left: 0xff8c00,
            right: 0xdc2626, front: 0x16a34a, back: 0x2563eb, inner: 0x0f172a
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(10, 20, 15);
            scene.add(sun);

            createCube();
            updateCameraPosition();
            animate();

            const el = renderer.domElement;
            el.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onResize);
        }

        function createCube() {
            cubes.forEach(c => scene.remove(c));
            cubes = [];
            const size = 0.96;
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [
                            new THREE.MeshLambertMaterial({ color: x === 1 ? COLORS.right : COLORS.inner }),
                            new THREE.MeshLambertMaterial({ color: x === -1 ? COLORS.left : COLORS.inner }),
                            new THREE.MeshLambertMaterial({ color: y === 1 ? COLORS.top : COLORS.inner }),
                            new THREE.MeshLambertMaterial({ color: y === -1 ? COLORS.bottom : COLORS.inner }),
                            new THREE.MeshLambertMaterial({ color: z === 1 ? COLORS.front : COLORS.inner }),
                            new THREE.MeshLambertMaterial({ color: z === -1 ? COLORS.back : COLORS.inner }),
                        ];
                        const geo = new THREE.BoxGeometry(size, size, size);
                        const cube = new THREE.Mesh(geo, materials);
                        cube.position.set(x, y, z);
                        
                        // 加入黑色細邊線讓色層更明顯
                        const edgesGeo = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edgesGeo, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                        cube.add(line);

                        scene.add(cube);
                        cubes.push(cube);
                    }
                }
            }
        }

        function onPointerDown(event) {
            if (isRotating) return;
            isDragging = true;
            dragStartPoint.set(event.clientX, event.clientY);

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                const hit = intersects[0];
                selectedData = {
                    object: hit.object,
                    point: hit.point.clone(),
                    normal: hit.face.normal.clone().applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize()
                };
            } else {
                selectedData = null;
            }
        }

        function onPointerMove(event) {
            if (!isDragging) return;

            const moveX = event.clientX - dragStartPoint.x;
            const moveY = event.clientY - dragStartPoint.y;
            const distance = Math.sqrt(moveX * moveX + moveY * moveY);

            if (selectedData) {
                if (distance > 10) { 
                    handleProjectedDrag(moveX, moveY);
                    isDragging = false; 
                }
            } else {
                lon -= moveX * 0.3;
                lat += moveY * 0.3;
                lat = Math.max(-85, Math.min(85, lat));
                dragStartPoint.set(event.clientX, event.clientY);
                updateCameraPosition();
            }
        }

        function onPointerUp() {
            isDragging = false;
        }

        function handleProjectedDrag(moveX, moveY) {
            if (isRotating || !selectedData) return;

            const dragVec = new THREE.Vector2(moveX, -moveY).normalize();
            const axes = [
                { axis: 'x', world: new THREE.Vector3(1, 0, 0) },
                { axis: 'y', world: new THREE.Vector3(0, 1, 0) },
                { axis: 'z', world: new THREE.Vector3(0, 0, 1) }
            ];

            let bestMatch = null;
            let maxDot = -Infinity;

            axes.forEach(a => {
                const tangent = new THREE.Vector3().crossVectors(a.world, selectedData.point).normalize();
                
                const p1 = selectedData.point.clone();
                const p2 = selectedData.point.clone().add(tangent.multiplyScalar(0.1));
                
                p1.project(camera);
                p2.project(camera);
                
                const screenVec = new THREE.Vector2(p2.x - p1.x, p2.y - p1.y).normalize();
                const dot = Math.abs(dragVec.dot(screenVec));

                if (dot > maxDot) {
                    maxDot = dot;
                    const direction = dragVec.dot(screenVec) > 0 ? 1 : -1;
                    bestMatch = {
                        axis: a.axis,
                        layer: Math.round(selectedData.object.position[a.axis]),
                        angle: direction * (Math.PI / 2)
                    };
                }
            });

            if (bestMatch) {
                rotateLayer(bestMatch.axis, bestMatch.layer, bestMatch.angle);
            }
        }

        async function rotateLayer(axis, layer, angle) {
            if (isRotating) return;
            isRotating = true;
            if (!timerRunning) startTimer();

            const pivot = new THREE.Group();
            scene.add(pivot);

            // 嚴格過濾該層方塊
            const movingCubes = cubes.filter(c => Math.abs(c.position[axis] - layer) < 0.2);
            movingCubes.forEach(c => pivot.attach(c));

            const duration = 250;
            const start = performance.now();

            return new Promise(resolve => {
                function step(now) {
                    const progress = Math.min((now - start) / duration, 1);
                    const t = progress * (2 - progress); 
                    pivot.rotation[axis] = t * angle;
                    if (progress < 1) requestAnimationFrame(step);
                    else {
                        pivot.updateMatrixWorld();
                        movingCubes.forEach(c => {
                            scene.attach(c);
                            // --- 關鍵修復：強制座標與旋轉校準 ---
                            c.position.x = Math.round(c.position.x);
                            c.position.y = Math.round(c.position.y);
                            c.position.z = Math.round(c.position.z);
                            c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                            c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                            c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);
                        });
                        scene.remove(pivot);
                        isRotating = false;
                        resolve();
                    }
                }
                requestAnimationFrame(step);
            });
        }

        function updateCameraPosition() {
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);
            camera.position.set(
                10 * Math.sin(phi) * Math.cos(theta),
                10 * Math.cos(phi),
                10 * Math.sin(phi) * Math.sin(theta)
            );
            camera.lookAt(target);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        let startTime, timerInterval, timerRunning = false;
        function startTimer() {
            if (timerRunning) return;
            startTime = Date.now();
            timerRunning = true;
            timerInterval = setInterval(() => {
                const d = Date.now() - startTime;
                const m = Math.floor(d/60000).toString().padStart(2, '0');
                const s = Math.floor((d%60000)/1000).toString().padStart(2, '0');
                const ms = Math.floor((d%1000)/10).toString().padStart(2, '0');
                document.getElementById('timer').innerText = `${m}:${s}.${ms}`;
            }, 10);
        }

        document.getElementById('scramble-btn').onclick = async () => {
            if (isRotating) return;
            clearInterval(timerInterval);
            timerRunning = false;
            document.getElementById('timer').innerText = "00:00.00";
            const axes = ['x', 'y', 'z'], layers = [-1, 0, 1];
            for (let i = 0; i < 15; i++) {
                await rotateLayer(axes[Math.floor(Math.random()*3)], layers[Math.floor(Math.random()*3)], (Math.random()>0.5?1:-1)*Math.PI/2);
            }
            startTimer();
        };

        document.getElementById('reset-btn').onclick = () => {
            clearInterval(timerInterval);
            timerRunning = false;
            document.getElementById('timer').innerText = "00:00.00";
            createCube();
        };

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
